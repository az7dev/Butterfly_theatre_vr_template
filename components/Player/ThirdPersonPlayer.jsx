/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from 'react';
import { OrbitControls } from '@react-three/drei';
import { useThree, useFrame } from '@react-three/fiber';
import { ContextData } from '../../context/Context';
import * as THREE from 'three';
// import { Character } from "./Character";
import { angleToRadians } from '../utils/angle';
// import { Cuboid } from "@dimforge/rapier3d-compat";
import { CapsuleCollider, RigidBody } from '@react-three/rapier';

let walkDirection = new THREE.Vector3();
let rotateAngle = new THREE.Vector3(0, 1, 0);
let rotateQuaternion = new THREE.Quaternion();
let cameraTarget = new THREE.Vector3();
// const frontVector = new THREE.Vector3();
// const sideVector = new THREE.Vector3();
const velocity = 5;
// const direction = new THREE.Vector3();

const directionOffset = ({ forward, backward, left, right }) => {
    // w key direction
    var directionOffset = 0;
    if (forward) {
        if (left) {
            directionOffset = Math.PI / 4; // w + a key direction
        } else if (right) {
            directionOffset = -Math.PI / 4; // w + d key direction
        }
    } else if (backward) {
        if (left) {
            directionOffset = Math.PI / 4 + Math.PI / 2; // s + a key direction
        } else if (right) {
            directionOffset = -Math.PI / 4 - Math.PI / 2; // s + d key direction
        } else {
            directionOffset = Math.PI; // s key direction
        }
    } else if (left) {
        directionOffset = Math.PI / 2; // a key direction
    } else if (right) {
        directionOffset = -Math.PI / 2; // d key direction
    }
    return directionOffset;
};

export default function ThirdPersonPlayer({ props }) {
    const [movement, setMovement] = React.useContext(ContextData);
    // const [actions, setActions] = React.useState("idle");
    const { forward, backward, left, right, room } = movement;
    // const group = useRef();
    const rigidBody = useRef();
    // const currentAction = useRef();
    const controlRef = useRef();
    const { camera } = useThree();

    const personPosition = {
        Home: [-90, 2, -0],
        Hall: [-50, 5, 0],
        FrontYard: [-9, 2, 2],
        Bedroom: [4, 3, 0],
        Terrace: [-4, 6, 1]
    };
    const [position, setPos] = React.useState(personPosition[room]);

    // const { animations, nodes, materials } = useGLTF(
    //   "/assets/model/character.glb"
    // );
    // const { actions } = useAnimations(animations, group);

    const UpdateCameraTarget = (moveX, moveZ) => {
        const rigidTranslation = rigidBody.current.translation();
        camera.position.x += moveX;
        camera.position.z += moveZ;

        // camera.position.y += 0.75;

        // update camera target
        // camera.position.set(...ref.current.translation());
        cameraTarget.x = rigidTranslation.x;
        cameraTarget.z = rigidTranslation.z;
        cameraTarget.y = rigidTranslation.y + 1;
        if (controlRef.current) {
            // // console.log("controlref");
            controlRef.current.target = cameraTarget;
        }
    };

    // React.useEffect(() => {
    //   invalidate(1);
    // }, [position, camera]);

    // React.useEffect(() => {
    //   UpdateCameraTarget(new THREE.Vector3(-1, 1, 1));
    //   // console.log("lol");
    // }, [camera]);

    React.useEffect(() => {
        UpdateCameraTarget(-12, 12);
        // camera.position.y = 1.75;
    }, [camera]);

    React.useEffect(() => {
        setPos(personPosition[room]);
    }, [room]);

    // React.useEffect(() => {
    //   if (forward || backward || left || right) {
    //     setActions("walking");
    //   } else if (jump) {
    //     setActions("jump");
    //   } else {
    //     setActions("idle");
    //   }
    //   // if (currentAction.current != action) {
    //   // const nextAction = actions[action];
    //   // const current = actions[currentAction.current];
    //   // current?.fadeOut(0.2);
    //   // nextAction?.reset().fadeIn(0.2).play();
    //   // currentAction.current = action;
    //   // }
    // }, [forward, backward, left, right, jump]);

    useFrame((state, delta) => {
        if (forward || backward || left || right) {
            // calculate camera direction
            const translation = rigidBody.current.translation();
            let angleYCameraDirection = Math.atan2(camera.position.x - translation.x, camera.position.z - translation.z);

            let newDirectionalOffset = directionOffset({
                forward,
                backward,
                left,
                right
            });

            rotateQuaternion.setFromAxisAngle(rotateAngle, angleYCameraDirection + newDirectionalOffset);

            // group.current.quaternion.rotateTowards(rotateQuaternion, 0.5);
            rigidBody.current.setRotation(rotateQuaternion, true);
            camera.getWorldDirection(walkDirection);
            walkDirection.y = 0;
            walkDirection.normalize();
            // walkDirection.applyEuler(camera.rotation);
            walkDirection.applyAxisAngle(rotateAngle, newDirectionalOffset);

            // const cameraPositionOffset = camera.position.sub(group.current.position);

            const moveX = walkDirection.x * velocity * delta;
            const moveZ = walkDirection.z * velocity * delta;

            // group.current.position.x += moveX;
            // group.current.position.z += moveZ;

            rigidBody.current.setTranslation(
                {
                    x: translation.x + moveX,
                    y: translation.y + 0,
                    z: translation.z + moveZ
                },
                true
            );
            UpdateCameraTarget(moveX, moveZ);
        } else {
            UpdateCameraTarget(0, 0);
        }
    });

    return (
        <>
            <OrbitControls
                ref={controlRef}
                mouseButtons={{ LEFT: THREE.MOUSE.ROTATE }}
                // panSpeed={0.25}
                rotateSpeed={0.25}
                minDistance={0.5}
                maxDistance={0.5}
                minPolarAngle={
                    forward === true || backward === true || left === true || right === true ? angleToRadians(95) : angleToRadians(50)
                }
                maxPolarAngle={
                    forward === true || backward === true || left === true || right === true ? angleToRadians(95) : angleToRadians(150)
                }
                zoomSpeed={0.5}
                enablePan={false}
                enableRotate={backward === true || left === true || right === true ? false : true}
                enableDamping={true}
            />

            <RigidBody
                // ref={group.current}
                ref={rigidBody}
                colliders={false}
                mass={60}
                type="dynamic"
                enabledRotations={[false, false, false]}
                position={position}
                canSleep={false}
                enableCcd={true}
                linearDamping={2}
            >
                {/* <MeshCollider> */}
                <CapsuleCollider args={[0, 0.4]} />
                {/* <group ref={group} {...props} dispose={null}>
          <group name="Scene">
            <group name="Armature" rotation={[Math.PI, 0, Math.PI]}>
              <primitive object={nodes.mixamorigHips} />
              <primitive object={nodes.Ctrl_Master} />
              <primitive object={nodes.Ctrl_ArmPole_IK_Left} />
              <primitive object={nodes.Ctrl_Hand_IK_Left} />
              <primitive object={nodes.Ctrl_ArmPole_IK_Right} />
              <primitive object={nodes.Ctrl_Hand_IK_Right} />
              <primitive object={nodes.Ctrl_Foot_IK_Left} />
              <primitive object={nodes.Ctrl_LegPole_IK_Left} />
              <primitive object={nodes.Ctrl_Foot_IK_Right} />
              <primitive object={nodes.Ctrl_LegPole_IK_Right} />
              <skinnedMesh
                name="Ch42_Sneakers"
                geometry={nodes.Ch42_Sneakers.geometry}
                material={materials.Ch42_Body}
                skeleton={nodes.Ch42_Sneakers.skeleton}
              />
            </group>
          </group>
        </group> */}
                {/* </CapsuleCollider> */}
                {/* </MeshCollider> */}
            </RigidBody>
        </>
    );
}
